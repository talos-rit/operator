# Operator


## Initial Setup
1. Clone the repo with `--recursive`to get the driver submodule:
```bash
git clone --recursive <repo-url>
```
*Note: Replace `<repo-url>` with the actual URL of the repository.*

## Compilation and Development
A Linux machine is required to develop and compile the operator. If you are on `macOS` or `Windows`, skip to [Additional Steps for macOS/Windows](#additional-steps-for-macoswindows).

### Compilation
1. run cmake

```bash
cmake -B build
```

2. run make

```bash
./make <executable>
```
See all of the options for executable [below](#options-for-executable).

3. run executable

./build/bin/<executable>


### Options for executable

1. `erv`

    Create erv binary at `./build/bin/erv`

2. `ichor`

    Create ichor binary at `./build/bin/ichor`

3. `test_all`

    Create and run all tests

4. `test_verbose`

    Create and run all tests with verbose output

5. `test_erv`

    Create and run ER V operator tests

6. `test_ichor`

    Create and run Ichor tests

7. `test_common`

    Create and run common library tests

8. `build_tests`

    Build test binaries without running them

9. `analyze`

    Runs static analysis tools:
    - `cppcheck` - generates html file in `build/analysis_reports/`
    - `clang-tidy` - generates ansi file in `build/analysis_reports/clang_tidy.ansi`

10. `test_erv_report`

    Run ER V operator tests and generate junit xml reports

11. `test_ichor_report`

    Run Ichor tests and generate junit xml reports

12. `test_common_report`

    Run common library tests and generate junit xml reports

13. `coverage_report`

    Generate code coverage report using lcov. Output saved to `build/coverage/index.html`


### Additional steps for macOS/Windows
If you are on `macOS` or `Windows`, it is impossible to compile the operator/driver directly. This makes development challenging since you are unable to use all the features of your IDE during development. You can use a Linux virtual machine (VM) or Docker to compile the operator. Below are the steps to set up a Dev Container for development. It is recommended to use the Dev Containers extension for VS Code for a smoother experience.

1. Install [Docker](https://www.docker.com/get-started/) and [VS Code](https://code.visualstudio.com/).
2. Install the [Dev Containers extension](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers) in VS Code. *Note: The installed Docker version needs to be compatible with the Dev Containers extension. Check the [documentation](https://code.visualstudio.com/docs/devcontainers/containers#_prerequisites) for more information.*
3. Open the cloned repository in VS Code.
4. Open the Command Palette (`Ctrl+Shift+P` or `Cmd+Shift+P` on macOS) and select `Dev Containers: Open Folder in Container`.

### Generating Documentation
#### UML Diagrams
UML diagrams can be generated using `clang-uml`. To install `clang-uml`, follow the installation instructions on the [clang-uml GitHub page](https://clang-uml.github.io/md_docs_2installation.html) for your OS. If you are using the Dev Container, `clang-uml` is already installed. 

Before you can use `clang-uml`, you need to generate a `compile_commands.json` file for the operator. This file is auto-generated by cmake. However, this file can also be generated using `bear`, which is already included if using the dev container. If you do not have `bear` installed, use the following command to install it:
```bash
apt-get install bear
```

### Running Tests
The tests are written using the `Cpputest` unit test framework. To learn more about `Cpputest` see the [Cpputest documentation](https://cpputest.github.io/manual.html). The test suite is split up into three different parts that are executed separately for each of the major components of operator and Ichor. Below are the commands for running the tests both with and without code coverage.

*Note: BEFORE running the tests, you should run the `make clean` command to ensure that all object files are rebuilt with the correct flags for code coverage if you plan to generate a coverage report. This only needs to be run once before running the test suites since we want the coverage to build off one another.*

#### Build and Run Unit Tests Without Coverage
```bash
# Build and execute all tests
make test_all

# Individual make commands
make test_common
make test_erv
make test_ichor
```

#### Build and Run Unit Tests With Coverage
```bash
# Individual make commands which generate junit xml reports for each test file
make test_common_report
make test_erv_report
make test_ichor_report

# **Currently not recommended**
# Build and execute all tests and generate junit xml reports for each test file
make test_all_report
```

#### Generating Code Coverage Report
A local version of the code coverage report can be generated using `lcov` and `genhtml`. If you are using the dev container, these tools should already be included. If not, `lcov` and `genhtml` can be downloaded with the following command.

```bash
apt-get install lcov
```
*Note: If you have any trouble please refer to the [lcov README](https://github.com/linux-test-project/lcov) for instructions on another method of installation.*

**Important:** Before running tests with coverage, run `make clean` to ensure all object files are rebuilt with coverage flags.

To generate the html coverage report, run the following command from the root of the repository:
```bash
# Using the make wrapper (recommended)
./make coverage_report
```

The generated report will be available at `build/coverage/index.html`.

### Running Static Analysis
Two different tools are currently used for static analysis of operator and Ichor code: `cppcheck` and `clang-tidy`. However, to use these tools you will also need to install `bear`, which is already included if using the dev container, to generate a compile_commands.json file for operator and Ichor. If you do not have `bear` installed, use the following command to install it:

```bash
apt-get install bear
```

After `bear` is installed, there are two approaches to running static analysis: using [make](#using-make) or a [manual approach](#manual-approach).

#### Using `make` bashscript
The make script exists because you have to run make in the build directory which just adds another friction, so we made a make script that takes in any arguments and pass it to the make command in the build directory.

For example, to run static analysis using `cppcheck` and `clang-tidy` with `make`, use the following command
```bash
# Using the make wrapper (recommended)
./make analyze
```

